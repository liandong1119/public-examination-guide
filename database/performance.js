// ‚ö° Êï∞ÊçÆÂ∫ìÊÄßËÉΩ‰ºòÂåñÊ®°Âùó
import NodeCache from 'node-cache';

class DatabasePerformance {
    constructor() {
        // ÂàùÂßãÂåñÁºìÂ≠ò
        this.cache = new NodeCache({
            stdTTL: 600, // ÈªòËÆ§10ÂàÜÈíüËøáÊúü
            checkperiod: 120, // ÊØè2ÂàÜÈíüÊ£ÄÊü•ËøáÊúü
            useClones: false // ÊèêÈ´òÊÄßËÉΩ
        });
        
        this.queryCache = new NodeCache({
            stdTTL: 300, // Êü•ËØ¢ÁºìÂ≠ò5ÂàÜÈíü
            checkperiod: 60
        });
        
        // ÊÄßËÉΩÁõëÊéß
        this.performanceMetrics = {
            queryCount: 0,
            cacheHits: 0,
            cacheMisses: 0,
            slowQueries: [],
            avgQueryTime: 0
        };
    }

    // üöÄ Êü•ËØ¢ÁºìÂ≠òË£ÖÈ•∞Âô®
    withCache(key, ttl = 300) {
        return (target, propertyName, descriptor) => {
            const method = descriptor.value;
            
            descriptor.value = async function(...args) {
                const cacheKey = `${key}_${JSON.stringify(args)}`;
                
                // Â∞ùËØï‰ªéÁºìÂ≠òËé∑Âèñ
                const cached = this.performance.queryCache.get(cacheKey);
                if (cached !== undefined) {
                    this.performance.performanceMetrics.cacheHits++;
                    return cached;
                }
                
                // ÊâßË°åÂéüÊñπÊ≥ï
                const startTime = Date.now();
                const result = await method.apply(this, args);
                const queryTime = Date.now() - startTime;
                
                // Êõ¥Êñ∞ÊÄßËÉΩÊåáÊ†á
                this.performance.updateMetrics(queryTime, propertyName);
                
                // ÁºìÂ≠òÁªìÊûú
                this.performance.queryCache.set(cacheKey, result, ttl);
                this.performance.performanceMetrics.cacheMisses++;
                
                return result;
            };
        };
    }

    // üìä Êõ¥Êñ∞ÊÄßËÉΩÊåáÊ†á
    updateMetrics(queryTime, queryName) {
        this.performanceMetrics.queryCount++;
        
        // ËÆ°ÁÆóÂπ≥ÂùáÊü•ËØ¢Êó∂Èó¥
        this.performanceMetrics.avgQueryTime = 
            (this.performanceMetrics.avgQueryTime * (this.performanceMetrics.queryCount - 1) + queryTime) 
            / this.performanceMetrics.queryCount;
        
        // ËÆ∞ÂΩïÊÖ¢Êü•ËØ¢ÔºàË∂ÖËøá1ÁßíÔºâ
        if (queryTime > 1000) {
            this.performanceMetrics.slowQueries.push({
                query: queryName,
                time: queryTime,
                timestamp: new Date().toISOString()
            });
            
            // Âè™‰øùÁïôÊúÄËøë50‰∏™ÊÖ¢Êü•ËØ¢
            if (this.performanceMetrics.slowQueries.length > 50) {
                this.performanceMetrics.slowQueries = this.performanceMetrics.slowQueries.slice(-50);
            }
        }
    }

    // üîç ‰ºòÂåñÁöÑÊü•ËØ¢ÊûÑÂª∫Âô®
    buildOptimizedQuery(table, options = {}) {
        let sql = `SELECT `;
        let params = [];
        
        // ÈÄâÊã©Â≠óÊÆµ‰ºòÂåñ
        if (options.fields && Array.isArray(options.fields)) {
            sql += options.fields.join(', ');
        } else {
            sql += '*';
        }
        
        sql += ` FROM ${table}`;
        
        // WHEREÊù°‰ª∂‰ºòÂåñ
        if (options.where && Object.keys(options.where).length > 0) {
            const conditions = [];
            Object.entries(options.where).forEach(([key, value]) => {
                if (Array.isArray(value)) {
                    // INÊü•ËØ¢‰ºòÂåñ
                    conditions.push(`${key} IN (${value.map(() => '?').join(', ')})`);
                    params.push(...value);
                } else if (typeof value === 'string' && value.includes('%')) {
                    // LIKEÊü•ËØ¢‰ºòÂåñ
                    conditions.push(`${key} LIKE ?`);
                    params.push(value);
                } else {
                    conditions.push(`${key} = ?`);
                    params.push(value);
                }
            });
            sql += ` WHERE ${conditions.join(' AND ')}`;
        }
        
        // JOIN‰ºòÂåñ
        if (options.joins && Array.isArray(options.joins)) {
            options.joins.forEach(join => {
                sql += ` ${join.type || 'LEFT'} JOIN ${join.table} ON ${join.condition}`;
            });
        }
        
        // ORDER BY‰ºòÂåñ
        if (options.orderBy) {
            sql += ` ORDER BY ${options.orderBy}`;
            if (options.orderDirection) {
                sql += ` ${options.orderDirection}`;
            }
        }
        
        // LIMIT‰ºòÂåñ
        if (options.limit) {
            sql += ` LIMIT ?`;
            params.push(options.limit);
            
            if (options.offset) {
                sql += ` OFFSET ?`;
                params.push(options.offset);
            }
        }
        
        return { sql, params };
    }

    // üìà ÊâπÈáèÊìç‰Ωú‰ºòÂåñ
    async batchInsert(db, table, records, batchSize = 100) {
        if (!records || records.length === 0) return [];
        
        const results = [];
        const fields = Object.keys(records[0]);
        
        for (let i = 0; i < records.length; i += batchSize) {
            const batch = records.slice(i, i + batchSize);
            
            // ÊûÑÂª∫ÊâπÈáèÊèíÂÖ•SQL
            const placeholders = batch.map(() => 
                `(${fields.map(() => '?').join(', ')})`
            ).join(', ');
            
            const sql = `INSERT INTO ${table} (${fields.join(', ')}) VALUES ${placeholders}`;
            
            // Â±ïÂπ≥ÂèÇÊï∞
            const params = batch.flatMap(record => fields.map(field => record[field]));
            
            try {
                const result = await db.query(sql, params);
                results.push(result);
            } catch (error) {
                console.error(`ÊâπÈáèÊèíÂÖ•Â§±Ë¥• (batch ${i / batchSize + 1}):`, error.message);
                throw error;
            }
        }
        
        return results;
    }

    // üîÑ ËøûÊé•Ê±†‰ºòÂåñÈÖçÁΩÆ
    getOptimizedPoolConfig(baseConfig) {
        return {
            ...baseConfig,
            // ËøûÊé•Ê±†Â§ßÂ∞è‰ºòÂåñ
            connectionLimit: parseInt(process.env.DB_CONNECTION_LIMIT) || 10,
            acquireTimeout: parseInt(process.env.DB_ACQUIRE_TIMEOUT) || 60000,
            timeout: parseInt(process.env.DB_TIMEOUT) || 60000,
            
            // ÊÄßËÉΩ‰ºòÂåñÈÖçÁΩÆ
            queueLimit: 0, // Êó†ÈôêÈòüÂàó
            reconnect: true,
            idleTimeout: 300000, // 5ÂàÜÈíüÁ©∫Èó≤Ë∂ÖÊó∂
            
            // Êü•ËØ¢‰ºòÂåñ
            multipleStatements: false, // ÂÆâÂÖ®ËÄÉËôë
            queryTimeout: 60000,
            
            // Â≠óÁ¨¶ÈõÜ‰ºòÂåñ
            charset: 'utf8mb4',
            timezone: '+08:00',
            
            // ÁºìÂÜ≤‰ºòÂåñ
            typeCast: function(field, next) {
                // ‰ºòÂåñÊó•ÊúüÁ±ªÂûãËΩ¨Êç¢
                if (field.type === 'DATETIME' || field.type === 'TIMESTAMP') {
                    return field.string();
                }
                return next();
            }
        };
    }

    // üìä Á¥¢ÂºïÂª∫ËÆÆÂàÜÊûê
    async analyzeIndexUsage(db) {
        try {
            // ÂàÜÊûêÊÖ¢Êü•ËØ¢
            const slowQueries = await db.query(`
                SELECT query_time, sql_text, rows_examined, rows_sent
                FROM mysql.slow_log 
                WHERE start_time > DATE_SUB(NOW(), INTERVAL 1 DAY)
                ORDER BY query_time DESC 
                LIMIT 10
            `);
            
            // ÂàÜÊûêÁ¥¢Âºï‰ΩøÁî®ÊÉÖÂÜµ
            const indexStats = await db.query(`
                SELECT 
                    TABLE_NAME,
                    INDEX_NAME,
                    CARDINALITY,
                    SUB_PART,
                    NULLABLE
                FROM information_schema.STATISTICS 
                WHERE TABLE_SCHEMA = DATABASE()
                ORDER BY TABLE_NAME, SEQ_IN_INDEX
            `);
            
            return {
                slowQueries: slowQueries || [],
                indexStats: indexStats || [],
                recommendations: this.generateIndexRecommendations(slowQueries, indexStats)
            };
        } catch (error) {
            console.warn('Á¥¢ÂºïÂàÜÊûêÂ§±Ë¥•:', error.message);
            return { recommendations: [] };
        }
    }

    // üí° ÁîüÊàêÁ¥¢ÂºïÂª∫ËÆÆ
    generateIndexRecommendations(slowQueries, indexStats) {
        const recommendations = [];
        
        // Âü∫‰∫éË°®ÁªìÊûÑÁöÑÂü∫Á°ÄÁ¥¢ÂºïÂª∫ËÆÆ
        const basicRecommendations = [
            {
                table: 'content',
                columns: ['status', 'category_id'],
                type: 'composite',
                reason: 'ÊèêÈ´òÂÜÖÂÆπÊü•ËØ¢ÊÄßËÉΩ'
            },
            {
                table: 'content',
                columns: ['published_at'],
                type: 'single',
                reason: '‰ºòÂåñÊó∂Èó¥ËåÉÂõ¥Êü•ËØ¢'
            },
            {
                table: 'visits',
                columns: ['visit_date', 'content_id'],
                type: 'composite',
                reason: 'ÊèêÈ´òËÆøÈóÆÁªüËÆ°Êü•ËØ¢ÊÄßËÉΩ'
            },
            {
                table: 'content_tags',
                columns: ['content_id', 'tag_id'],
                type: 'composite',
                reason: '‰ºòÂåñÊ†áÁ≠æÂÖ≥ËÅîÊü•ËØ¢'
            }
        ];
        
        recommendations.push(...basicRecommendations);
        
        return recommendations;
    }

    // üóÇÔ∏è ÁºìÂ≠òÁÆ°ÁêÜ
    clearCache(pattern = null) {
        if (pattern) {
            // Ê∏ÖÈô§ÂåπÈÖçÊ®°ÂºèÁöÑÁºìÂ≠ò
            const keys = this.cache.keys();
            keys.forEach(key => {
                if (key.includes(pattern)) {
                    this.cache.del(key);
                }
            });
            
            const queryKeys = this.queryCache.keys();
            queryKeys.forEach(key => {
                if (key.includes(pattern)) {
                    this.queryCache.del(key);
                }
            });
        } else {
            // Ê∏ÖÈô§ÊâÄÊúâÁºìÂ≠ò
            this.cache.flushAll();
            this.queryCache.flushAll();
        }
    }

    // üìä Ëé∑ÂèñÊÄßËÉΩÊä•Âëä
    getPerformanceReport() {
        const cacheStats = this.cache.getStats();
        const queryCacheStats = this.queryCache.getStats();
        
        return {
            metrics: this.performanceMetrics,
            cache: {
                main: cacheStats,
                query: queryCacheStats,
                hitRate: this.performanceMetrics.cacheHits / 
                        (this.performanceMetrics.cacheHits + this.performanceMetrics.cacheMisses) * 100
            },
            recommendations: this.getPerformanceRecommendations()
        };
    }

    // üí° ÊÄßËÉΩÂª∫ËÆÆ
    getPerformanceRecommendations() {
        const recommendations = [];
        
        // ÁºìÂ≠òÂëΩ‰∏≠ÁéáÂª∫ËÆÆ
        const hitRate = this.performanceMetrics.cacheHits / 
                       (this.performanceMetrics.cacheHits + this.performanceMetrics.cacheMisses) * 100;
        
        if (hitRate < 70) {
            recommendations.push({
                type: 'cache',
                message: 'ÁºìÂ≠òÂëΩ‰∏≠ÁéáËæÉ‰ΩéÔºåÂª∫ËÆÆÂ¢ûÂä†ÁºìÂ≠òÊó∂Èó¥Êàñ‰ºòÂåñÁºìÂ≠òÁ≠ñÁï•'
            });
        }
        
        // ÊÖ¢Êü•ËØ¢Âª∫ËÆÆ
        if (this.performanceMetrics.slowQueries.length > 10) {
            recommendations.push({
                type: 'query',
                message: 'Â≠òÂú®ËæÉÂ§öÊÖ¢Êü•ËØ¢ÔºåÂª∫ËÆÆ‰ºòÂåñSQLËØ≠Âè•ÊàñÊ∑ªÂä†Á¥¢Âºï'
            });
        }
        
        // Âπ≥ÂùáÊü•ËØ¢Êó∂Èó¥Âª∫ËÆÆ
        if (this.performanceMetrics.avgQueryTime > 500) {
            recommendations.push({
                type: 'performance',
                message: 'Âπ≥ÂùáÊü•ËØ¢Êó∂Èó¥ËæÉÈïøÔºåÂª∫ËÆÆÊ£ÄÊü•Êï∞ÊçÆÂ∫ìÈÖçÁΩÆÂíåÁ¥¢Âºï'
            });
        }
        
        return recommendations;
    }

    // üîß Êï∞ÊçÆÂ∫ìÁª¥Êä§
    async performMaintenance(db) {
        console.log('üîß ÂºÄÂßãÊï∞ÊçÆÂ∫ìÁª¥Êä§...');
        
        try {
            // ‰ºòÂåñË°®
            const tables = ['users', 'content', 'categories', 'tags', 'visits', 'analytics'];
            
            for (const table of tables) {
                await db.query(`OPTIMIZE TABLE ${table}`);
                console.log(`‚úÖ ‰ºòÂåñË°® ${table} ÂÆåÊàê`);
            }
            
            // Êõ¥Êñ∞Ë°®ÁªüËÆ°‰ø°ÊÅØ
            for (const table of tables) {
                await db.query(`ANALYZE TABLE ${table}`);
                console.log(`üìä ÂàÜÊûêË°® ${table} ÂÆåÊàê`);
            }
            
            console.log('‚úÖ Êï∞ÊçÆÂ∫ìÁª¥Êä§ÂÆåÊàê');
            
        } catch (error) {
            console.error('‚ùå Êï∞ÊçÆÂ∫ìÁª¥Êä§Â§±Ë¥•:', error.message);
        }
    }
}

export default DatabasePerformance;
